# Instant prompt preamble (must be first)
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# XDG Base Directories
export XDG_DATA_HOME=$HOME/.local/share
export XDG_CONFIG_HOME=$HOME/.config
export XDG_STATE_HOME=$HOME/.local/state
export XDG_CACHE_HOME=$HOME/.cache

# Locale and terminal settings
export LANG=en_CA.UTF-8
export LC_ALL=en_CA.UTF-8
export TERM=xterm-256color

# Path setup (chezmoi template logic)
# WSL Path Management - prioritize Linux binaries over Windows
if [[ -n "${WSL_DISTRO_NAME:-}" ]] || [[ -n "${WSL_INTEROP:-}" ]]; then
    # Remove Windows paths that might interfere with Linux development tools
    export PATH=$(echo "$PATH" | tr ':' '\n' | grep -v '/mnt/[a-z]/' | tr '\n' ':' | sed 's/:$//')
fi

# Prioritize snap binaries and local installations
export PATH="/snap/bin:$HOME/.local/bin:$PATH"

# Add local npm global bin to PATH (but after snap)
if [[ -d "$HOME/.local/npm-global/bin" ]]; then
    export PATH="$PATH:$HOME/.local/npm-global/bin"
fi

# Path setup (chezmoi template logic)
{{- $paths := list }}
{{- $homeDir := .chezmoi.homeDir }}
{{- range $_, $relPath := list "bin" "usr/local/bin" "usr/local/go/bin" ".cargo/bin" ".local/bin" }}
{{    $path := joinPath $homeDir $relPath }}
{{-   if stat $path }}
{{-     $paths = mustAppend $paths $path }}
{{-   end }}
{{- end }}
{{- if $paths }}
export PATH={{ toStrings $paths | join ":" }}:$PATH
{{- end }}

# Oh-my-zsh setup
export ZSH=$HOME/.oh-my-zsh
ZSH_THEME="powerlevel10k/powerlevel10k"
CASE_SENSITIVE="true"
DISABLE_AUTO_UPDATE="true"
HIST_STAMPS="yyyy-mm-dd"
ZSH_DISABLE_COMPFIX=true

# Plugins
plugins=(
{{- $zshPlugins := or .zshPlugins (list) -}}
{{- range $zshPlugins }}
{{ . }}
{{- end }}
)

source $ZSH/oh-my-zsh.sh

# User configuration
PROMPT="%{$fg[white]%}%n@%{$fg[green]%}%m%{$reset_color%} ${PROMPT}"

setopt autocd
setopt histignorespace
setopt rm_star_silent

# Load aliases and functions
[[ -f ~/.zsh/aliases.zsh ]] && source ~/.zsh/aliases.zsh
[[ -f ~/.zsh/functions.zsh ]] && source ~/.zsh/functions.zsh

alias g=git
alias gnp="git --no-pager"
{{- if lookPath "bat" }}
alias cat=bat
{{- else if lookPath "batcat" }}
alias cat=batcat
{{- end }}
{{- if lookPath "fdfind" }}
alias fd=fdfind
{{- end }}
{{- if lookPath "eza" }}
alias ls=eza
{{- end }}

{{ if stat (printf "%s/.local/bin/nvim" .chezmoi.homeDir) -}}
export EDITOR=$HOME/.local/bin/nvim
{{ else if lookPath "nvim" -}}
export EDITOR=nvim
{{ else -}}
export EDITOR=vim
{{ end -}}

# Bitwarden field helper
bitwardenField() {
  # Usage: bitwardenField <item_name> <field_path>
  local item="$1"
  local field="$2"
  bw get item "$item" | jq -r "$field" 2>/dev/null || echo ""
}

# Bitwarden session management
bw_login_session() {
  if ! command -v bw >/dev/null 2>&1; then
    echo "‚ùå Bitwarden CLI not found"
    return 1
  fi

  echo "üîê Logging into Bitwarden..."

  # Check if already logged in but locked
  local bw_status=$(bw status 2>/dev/null)
  if echo "$bw_status" | grep -q "locked"; then
    echo "‚ÑπÔ∏è  Already logged in but vault is locked. Use 'bwunlock' instead."
    return bw_unlock_session
  fi

  # Attempt login and capture the session from output
  local login_output=$(bw login 2>&1)
  local exit_code=$?

  if [[ $exit_code -eq 0 ]]; then
    # Extract session from the login output
    local session=$(echo "$login_output" | grep -o 'BW_SESSION="[^"]*"' | sed 's/BW_SESSION="\([^"]*\)"/\1/' | head -1)

    if [[ -n "$session" ]]; then
      export BW_SESSION="$session"
      mkdir -p "$HOME/.config"
      echo "$session" > "$HOME/.config/bw-session"
      chmod 600 "$HOME/.config/bw-session"
      echo "‚úÖ Bitwarden login successful and session saved"

      # Export GitHub token if available
      if command -v jq >/dev/null 2>&1; then
        sleep 1  # Brief pause for session to be fully active
        export GITHUB_ACCESS_TOKEN="$(bitwardenField 'GITHUB_TOKEN' '.CLI.value')"
        if [[ -n "$GITHUB_ACCESS_TOKEN" ]]; then
          echo "‚úÖ GitHub token exported"
        fi
      fi
    else
      echo "‚ö†Ô∏è  Login successful but couldn't extract session. Please run:"
      echo "export BW_SESSION=\"<session_key_from_above>\""
      echo ""
      echo "Login output:"
      echo "$login_output"
    fi
  else
    echo "‚ùå Bitwarden login failed"
    echo "$login_output"
    return 1
  fi
}

bw_restore_session() {
  if [[ -f "$HOME/.config/bw-session" ]]; then
    local saved_session=$(cat "$HOME/.config/bw-session" 2>/dev/null)
    if [[ -n "$saved_session" ]]; then
      export BW_SESSION="$saved_session"

      # Test if the session is still valid
      if bw status 2>/dev/null | grep -q "authenticated"; then
        # Export GitHub token if available
        if command -v jq >/dev/null 2>&1; then
          export GITHUB_ACCESS_TOKEN="$(bitwardenField 'GITHUB_TOKEN' '.CLI.value' 2>/dev/null)"
        fi
        return 0
      else
        # Session expired, remove it
        rm -f "$HOME/.config/bw-session"
        unset BW_SESSION
        return 1
      fi
    fi
  fi
  return 1
}

bw_unlock_session() {
  if ! command -v bw >/dev/null 2>&1; then
    echo "‚ùå Bitwarden CLI not found"
    return 1
  fi

  # Check current status
  local bw_status=$(bw status 2>/dev/null)
  if echo "$bw_status" | grep -q "unauthenticated"; then
    echo "‚ùå Not logged in. Use 'bwlogin' first."
    return 1
  fi

  if echo "$bw_status" | grep -q "authenticated"; then
    echo "‚úÖ Vault is already unlocked"
    return 0
  fi

  echo "üîì Unlocking Bitwarden vault..."

  # Try to unlock - this will prompt for master password
  local unlock_output=$(bw unlock --raw 2>/dev/null)
  local exit_code=$?

  if [[ $exit_code -eq 0 && -n "$unlock_output" ]]; then
    export BW_SESSION="$unlock_output"
    mkdir -p "$HOME/.config"
    echo "$unlock_output" > "$HOME/.config/bw-session"
    chmod 600 "$HOME/.config/bw-session"
    echo "‚úÖ Bitwarden vault unlocked and session saved"

    # Export GitHub token if available
    if command -v jq >/dev/null 2>&1; then
      export GITHUB_ACCESS_TOKEN="$(bitwardenField 'GITHUB_TOKEN' '.CLI.value')"
      if [[ -n "$GITHUB_ACCESS_TOKEN" ]]; then
        echo "‚úÖ GitHub token exported"
      fi
    fi
  else
    echo "‚ùå Bitwarden unlock failed"
    # Clear any invalid session
    unset BW_SESSION
    rm -f "$HOME/.config/bw-session"
    return 1
  fi
}

bw_logout_session() {
  if command -v bw >/dev/null 2>&1; then
    bw logout >/dev/null 2>&1
  fi
  unset BW_SESSION
  unset GITHUB_ACCESS_TOKEN
  rm -f "$HOME/.config/bw-session"
  echo "‚úÖ Bitwarden session cleared"
}

# Aliases for convenience
alias bwlogin='bw_login_session'
alias bwunlock='bw_unlock_session'
alias bwlogout='bw_logout_session'

{{ if not .ephemeral -}}
# Bitwarden CLI setup (silent during shell init)
if command -v bw >/dev/null 2>&1; then
  BW_PATH=$(which bw)

  # Set up Bitwarden session management
  if [[ "$BW_PATH" == /snap/* ]] || timeout 2 bw --version >/dev/null 2>&1; then
    # Try to restore existing session silently
    bw_restore_session >/dev/null 2>&1
  fi
fi
{{ end -}}

export GOBIN=$HOME/.local/bin
export GOPATH=$HOME
export GO111MODULE=on
export LANG=en_CA.UTF-8
export LC_ALL=en_CA.UTF-8
export RIPGREP_CONFIG_PATH=~/.config/ripgrep/config

# Powerlevel10k config
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

{{ if stat (joinPath .chezmoi.homeDir ".nvm") }}
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
{{ end }}

# Async shell initialization (runs after prompt is ready)
async_shell_init() {
  # Longer delay to ensure prompt is fully ready and visible
  sleep 1

  # Clear the line and show system info
  echo ""
  echo "üñ•Ô∏è  System Information:"
  echo "====================="

  # Show system info with fastfetch
  if command -v fastfetch >/dev/null 2>&1; then
    fastfetch --size-binary-prefix JEDEC
  fi

  echo ""
  echo "üîê Security Status:"
  echo "=================="

{{ if not .ephemeral -}}
  # Bitwarden status check
  if command -v bw >/dev/null 2>&1; then
    BW_PATH=$(which bw)

    if [[ "$BW_PATH" == /snap/* ]] || timeout 2 bw --version >/dev/null 2>&1; then
      local bw_status=$(bw status 2>/dev/null)

      if echo "$bw_status" | grep -q "unauthenticated"; then
        echo "üîê Bitwarden CLI available but not authenticated"
        echo "   Run 'bwlogin' to authenticate when ready"
      elif echo "$bw_status" | grep -q "locked"; then
        echo "üîí Bitwarden vault is locked"
        echo "   Run 'bwunlock' to unlock your vault"
      elif echo "$bw_status" | grep -q "authenticated"; then
        echo "‚úÖ Bitwarden CLI authenticated and ready"
        if [[ -n "$GITHUB_ACCESS_TOKEN" ]]; then
          echo "‚úÖ GitHub token available"
        fi
      fi
    elif [[ "$BW_PATH" == /mnt/* ]]; then
      echo "‚ö†Ô∏è  Found Windows Bitwarden CLI - use '/snap/bin/bw' for Linux version"
    else
      echo "‚ö†Ô∏è  Bitwarden CLI found but not working - try '/snap/bin/bw' instead"
    fi
  else
    echo "‚ÑπÔ∏è  Bitwarden CLI not found - check installation scripts"
  fi
{{ end -}}

  echo ""
  echo "üöÄ Development environment ready!"
  echo "================================"
  echo ""
}

sysinfo() {
  echo "üñ•Ô∏è  System Information:"
  echo "====================="
  if command -v fastfetch >/dev/null 2>&1; then
    fastfetch --size-binary-prefix JEDEC
  fi
  echo ""

  if command -v bw >/dev/null 2>&1; then
    local bw_status=$(bw status 2>/dev/null)
    echo "üîê Bitwarden Status:"
    echo "=================="

    if echo "$bw_status" | grep -q "authenticated"; then
      echo "‚úÖ Authenticated and ready"
    elif echo "$bw_status" | grep -q "locked"; then
      echo "üîí Logged in but locked - run 'bwunlock'"
    else
      echo "üîê Not authenticated - run 'bwlogin'"
    fi
  fi
  echo ""
}

# Run async initialization in background after shell loads
if [[ -o interactive ]]; then
  # Use zsh/zpty module for true async execution
  zmodload zsh/zpty 2>/dev/null || {
    # Fallback: simple background job
    (async_shell_init &)
  }

  if (( $+modules[zsh/zpty] )); then
    zpty async_init async_shell_init
    zpty -r async_init
  fi
fi

{{- /* vim: set filetype=zsh: */}}
