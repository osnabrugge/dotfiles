# Instant prompt preamble (must be first)
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# XDG Base Directories
export XDG_DATA_HOME=$HOME/.local/share
export XDG_CONFIG_HOME=$HOME/.config
export XDG_STATE_HOME=$HOME/.local/state
export XDG_CACHE_HOME=$HOME/.cache

# Locale and terminal settings
export LANG=en_CA.UTF-8
export LC_ALL=en_CA.UTF-8
export TERM=xterm-256color

# Path setup (chezmoi template logic)
# WSL Path Management - prioritize Linux binaries over Windows
if [[ -n "${WSL_DISTRO_NAME:-}" ]] || [[ -n "${WSL_INTEROP:-}" ]]; then
    # Remove Windows paths that might interfere with Linux development tools
    export PATH=$(echo "$PATH" | tr ':' '\n' | grep -v '/mnt/[a-z]/' | tr '\n' ':' | sed 's/:$//')
fi

# Prioritize snap binaries and local installations
export PATH="/snap/bin:$HOME/.local/bin:$PATH"

# Add local npm global bin to PATH (but after snap)
if [[ -d "$HOME/.local/npm-global/bin" ]]; then
    export PATH="$PATH:$HOME/.local/npm-global/bin"
fi

# Path setup (chezmoi template logic)
{{- $paths := list }}
{{- $homeDir := .chezmoi.homeDir }}
{{- range $_, $relPath := list "bin" "usr/local/bin" "usr/local/go/bin" ".cargo/bin" ".local/bin" }}
{{    $path := joinPath $homeDir $relPath }}
{{-   if stat $path }}
{{-     $paths = mustAppend $paths $path }}
{{-   end }}
{{- end }}
{{- if $paths }}
export PATH={{ toStrings $paths | join ":" }}:$PATH
{{- end }}

# Oh-my-zsh setup
export ZSH=$HOME/.oh-my-zsh
ZSH_THEME="powerlevel10k/powerlevel10k"
CASE_SENSITIVE="true"
DISABLE_AUTO_UPDATE="true"
HIST_STAMPS="yyyy-mm-dd"
ZSH_DISABLE_COMPFIX=true

# Plugins
plugins=(
{{- $zshPlugins := or .zshPlugins (list) -}}
{{- range $zshPlugins }}
{{ . }}
{{- end }}
)

source $ZSH/oh-my-zsh.sh

# User configuration
PROMPT="%{$fg[white]%}%n@%{$fg[green]%}%m%{$reset_color%} ${PROMPT}"

setopt autocd
setopt histignorespace
setopt rm_star_silent

# Load aliases and functions
[[ -f ~/.zsh/aliases.zsh ]] && source ~/.zsh/aliases.zsh
[[ -f ~/.zsh/functions.zsh ]] && source ~/.zsh/functions.zsh

alias g=git
alias gnp="git --no-pager"
{{- if lookPath "bat" }}
alias cat=bat
{{- else if lookPath "batcat" }}
alias cat=batcat
{{- end }}
{{- if lookPath "fdfind" }}
alias fd=fdfind
{{- end }}
{{- if lookPath "eza" }}
alias ls=eza
{{- end }}

{{ if stat (printf "%s/.local/bin/nvim" .chezmoi.homeDir) -}}
export EDITOR=$HOME/.local/bin/nvim
{{ else if lookPath "nvim" -}}
export EDITOR=nvim
{{ else -}}
export EDITOR=vim
{{ end -}}

# Bitwarden field helper
bitwardenField() {
  # Usage: bitwardenField <item_name> <field_path>
  local item="$1"
  local field="$2"
  bw get item "$item" | jq -r "$field" 2>/dev/null || echo ""
}

# Bitwarden session management
bw_login_session() {
  if ! command -v bw >/dev/null 2>&1; then
    echo "❌ Bitwarden CLI not found"
    return 1
  fi

  echo "🔐 Logging into Bitwarden..."
  local session=$(bw login --raw 2>/dev/null)

  if [[ $? -eq 0 && -n "$session" ]]; then
    export BW_SESSION="$session"
    mkdir -p "$HOME/.config"
    echo "$session" > "$HOME/.config/bw-session"
    chmod 600 "$HOME/.config/bw-session"
    echo "✅ Bitwarden login successful"

    # Export GitHub token if available
    if command -v jq >/dev/null 2>&1; then
      export GITHUB_ACCESS_TOKEN="$(bitwardenField 'GITHUB_TOKEN' '.CLI.value')"
      if [[ -n "$GITHUB_ACCESS_TOKEN" ]]; then
        echo "✅ GitHub token exported"
      fi
    fi
  else
    echo "❌ Bitwarden login failed"
    return 1
  fi
}

bw_unlock_session() {
  if ! command -v bw >/dev/null 2>&1; then
    echo "❌ Bitwarden CLI not found"
    return 1
  fi

  echo "🔓 Unlocking Bitwarden vault..."
  local session=$(bw unlock --raw 2>/dev/null)

  if [[ $? -eq 0 && -n "$session" ]]; then
    export BW_SESSION="$session"
    mkdir -p "$HOME/.config"
    echo "$session" > "$HOME/.config/bw-session"
    chmod 600 "$HOME/.config/bw-session"
    echo "✅ Bitwarden vault unlocked"

    # Export GitHub token if available
    if command -v jq >/dev/null 2>&1; then
      export GITHUB_ACCESS_TOKEN="$(bitwardenField 'GITHUB_TOKEN' '.CLI.value')"
      if [[ -n "$GITHUB_ACCESS_TOKEN" ]]; then
        echo "✅ GitHub token exported"
      fi
    fi
  else
    echo "❌ Bitwarden unlock failed"
    return 1
  fi
}

bw_logout_session() {
  if command -v bw >/dev/null 2>&1; then
    bw logout >/dev/null 2>&1
  fi
  unset BW_SESSION
  unset GITHUB_ACCESS_TOKEN
  rm -f "$HOME/.config/bw-session"
  echo "✅ Bitwarden session cleared"
}

# Aliases for convenience
alias bwlogin='bw_login_session'
alias bwunlock='bw_unlock_session'
alias bwlogout='bw_logout_session'

{{ if not .ephemeral -}}
# Bitwarden CLI setup (silent during shell init)
if command -v bw >/dev/null 2>&1; then
  BW_PATH=$(which bw)

  # Set up Bitwarden session management
  if [[ "$BW_PATH" == /snap/* ]] || timeout 2 bw --version >/dev/null 2>&1; then
    # Try to restore existing session
    if [[ -f "$HOME/.config/bw-session" ]]; then
      export BW_SESSION=$(cat "$HOME/.config/bw-session" 2>/dev/null)
    fi

    # Export GitHub token if authenticated
    if [[ -n "$BW_SESSION" ]] && command -v jq >/dev/null 2>&1; then
      if bw status 2>/dev/null | grep -q "authenticated"; then
        export GITHUB_ACCESS_TOKEN="$(bitwardenField 'GITHUB_TOKEN' '.CLI.value' 2>/dev/null)"
      fi
    fi
  fi
fi
{{ end -}}

export GOBIN=$HOME/.local/bin
export GOPATH=$HOME
export GO111MODULE=on
export LANG=en_CA.UTF-8
export LC_ALL=en_CA.UTF-8
export RIPGREP_CONFIG_PATH=~/.config/ripgrep/config

# Powerlevel10k config
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

{{ if stat (joinPath .chezmoi.homeDir ".nvm") }}
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
{{ end }}

# Async shell initialization (runs after prompt is ready)
async_shell_init() {
  # Show system info with fastfetch
  if command -v fastfetch >/dev/null 2>&1; then
    fastfetch --size-binary-prefix JEDEC
    echo ""
  fi

{{ if not .ephemeral -}}
  # Bitwarden status check
  if command -v bw >/dev/null 2>&1; then
    BW_PATH=$(which bw)

    if [[ "$BW_PATH" == /snap/* ]] || timeout 2 bw --version >/dev/null 2>&1; then
      local bw_status=$(bw status 2>/dev/null)

      if echo "$bw_status" | grep -q "unauthenticated"; then
        echo "🔐 Bitwarden CLI available but not authenticated"
        echo "Run 'bw login' to authenticate when ready"
      elif echo "$bw_status" | grep -q "locked"; then
        echo "🔒 Bitwarden vault is locked"
        echo "Run 'bw unlock' to unlock your vault"
      elif echo "$bw_status" | grep -q "authenticated"; then
        echo "✅ Bitwarden CLI authenticated and ready"
      fi
    elif [[ "$BW_PATH" == /mnt/* ]]; then
      echo "⚠️  Found Windows Bitwarden CLI - use '/snap/bin/bw' for Linux version"
    else
      echo "⚠️  Bitwarden CLI found but not working - try '/snap/bin/bw' instead"
    fi
  else
    echo "ℹ️  Bitwarden CLI not found - check installation scripts"
  fi
{{ end -}}
}

# Run async initialization in background after shell loads
if [[ -o interactive ]]; then
  # Use zsh/zpty module for true async execution
  zmodload zsh/zpty 2>/dev/null || {
    # Fallback: simple background job
    (async_shell_init &)
  }

  if (( $+modules[zsh/zpty] )); then
    zpty async_init async_shell_init
    zpty -r async_init
  fi
fi

{{- /* vim: set filetype=zsh: */}}
